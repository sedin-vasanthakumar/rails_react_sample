import*as e from"react";import{UNSAFE_invariant as t,joinPaths as r,matchPath as o,UNSAFE_getResolveToMatches as n,UNSAFE_warning as a,resolveTo as u,parsePath as s,matchRoutes as l,Action as i,isRouteErrorResponse as c,UNSAFE_convertRouteMatchToUiMatch as d,stripBasename as p,IDLE_BLOCKER as h,createMemoryHistory as v,AbortedDeferredError as m,createRouter as f}from"@remix-run/router";export{AbortedDeferredError,Action as NavigationType,createPath,defer,generatePath,isRouteErrorResponse,json,matchPath,matchRoutes,parsePath,redirect,redirectDocument,resolvePath}from"@remix-run/router";
/**
 * React Router v6.22.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function _extends(){_extends=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(e[o]=r[o])}return e};return _extends.apply(this,arguments)}const E=e.createContext(null);process.env.NODE_ENV!=="production"&&(E.displayName="DataRouter");const R=e.createContext(null);process.env.NODE_ENV!=="production"&&(R.displayName="DataRouterState");const y=e.createContext(null);process.env.NODE_ENV!=="production"&&(y.displayName="Await");const g=e.createContext(null);process.env.NODE_ENV!=="production"&&(g.displayName="Navigation");const N=e.createContext(null);process.env.NODE_ENV!=="production"&&(N.displayName="Location");const C=e.createContext({outlet:null,matches:[],isDataRoute:false});process.env.NODE_ENV!=="production"&&(C.displayName="Route");const D=e.createContext(null);process.env.NODE_ENV!=="production"&&(D.displayName="RouteError");function useHref(o,n){let{relative:a}=n===void 0?{}:n;useInRouterContext()?void 0:process.env.NODE_ENV!=="production"?t(false,"useHref() may be used only in the context of a <Router> component."):t(false);let{basename:u,navigator:s}=e.useContext(g);let{hash:l,pathname:i,search:c}=useResolvedPath(o,{relative:a});let d=i;u!=="/"&&(d=i==="/"?u:r([u,i]));return s.createHref({pathname:d,search:c,hash:l})}function useInRouterContext(){return e.useContext(N)!=null}function useLocation(){useInRouterContext()?void 0:process.env.NODE_ENV!=="production"?t(false,"useLocation() may be used only in the context of a <Router> component."):t(false);return e.useContext(N).location}function useNavigationType(){return e.useContext(N).navigationType}function useMatch(r){useInRouterContext()?void 0:process.env.NODE_ENV!=="production"?t(false,"useMatch() may be used only in the context of a <Router> component."):t(false);let{pathname:n}=useLocation();return e.useMemo((()=>o(r,n)),[n,r])}const b="You should call navigate() in a React.useEffect(), not when your component is first rendered.";function useIsomorphicLayoutEffect(t){let r=e.useContext(g).static;r||e.useLayoutEffect(t)}function useNavigate(){let{isDataRoute:t}=e.useContext(C);return t?useNavigateStable():useNavigateUnstable()}function useNavigateUnstable(){useInRouterContext()?void 0:process.env.NODE_ENV!=="production"?t(false,"useNavigate() may be used only in the context of a <Router> component."):t(false);let o=e.useContext(E);let{basename:s,future:l,navigator:i}=e.useContext(g);let{matches:c}=e.useContext(C);let{pathname:d}=useLocation();let p=JSON.stringify(n(c,l.v7_relativeSplatPath));let h=e.useRef(false);useIsomorphicLayoutEffect((()=>{h.current=true}));let v=e.useCallback((function(e,t){t===void 0&&(t={});process.env.NODE_ENV!=="production"?a(h.current,b):void 0;if(!h.current)return;if(typeof e==="number"){i.go(e);return}let n=u(e,JSON.parse(p),d,t.relative==="path");o==null&&s!=="/"&&(n.pathname=n.pathname==="/"?s:r([s,n.pathname]));(!t.replace?i.push:i.replace)(n,t.state,t)}),[s,i,p,d,o]);return v}const x=e.createContext(null);function useOutletContext(){return e.useContext(x)}function useOutlet(t){let r=e.useContext(C).outlet;return r?e.createElement(x.Provider,{value:t},r):r}function useParams(){let{matches:t}=e.useContext(C);let r=t[t.length-1];return r?r.params:{}}function useResolvedPath(t,r){let{relative:o}=r===void 0?{}:r;let{future:a}=e.useContext(g);let{matches:s}=e.useContext(C);let{pathname:l}=useLocation();let i=JSON.stringify(n(s,a.v7_relativeSplatPath));return e.useMemo((()=>u(t,JSON.parse(i),l,o==="path")),[t,i,l,o])}function useRoutes(e,t){return useRoutesImpl(e,t)}function useRoutesImpl(o,n,u,c){useInRouterContext()?void 0:process.env.NODE_ENV!=="production"?t(false,"useRoutes() may be used only in the context of a <Router> component."):t(false);let{navigator:d}=e.useContext(g);let{matches:p}=e.useContext(C);let h=p[p.length-1];let v=h?h.params:{};let m=h?h.pathname:"/";let f=h?h.pathnameBase:"/";let E=h&&h.route;if(process.env.NODE_ENV!=="production"){let e=E&&E.path||"";warningOnce(m,!E||e.endsWith("*"),'You rendered descendant <Routes> (or called `useRoutes()`) at "'+m+'" (under <Route path="'+e+'">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won\'t match anymore and therefore the child routes will never render.\n\nPlease change the parent <Route path="'+e+'"> to <Route path="'+(e==="/"?"*":e+"/*")+'">.')}let R=useLocation();let y;if(n){var D;let e=typeof n==="string"?s(n):n;f==="/"||((D=e.pathname)==null?void 0:D.startsWith(f))?void 0:process.env.NODE_ENV!=="production"?t(false,'When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "'+f+'" but pathname "'+e.pathname+'" was given in the `location` prop.'):t(false);y=e}else y=R;let b=y.pathname||"/";let x=b;if(f!=="/"){let e=f.replace(/^\//,"").split("/");let t=b.replace(/^\//,"").split("/");x="/"+t.slice(e.length).join("/")}let _=l(o,{pathname:x});if(process.env.NODE_ENV!=="production"){process.env.NODE_ENV!=="production"?a(E||_!=null,'No routes matched location "'+y.pathname+y.search+y.hash+'" '):void 0;process.env.NODE_ENV!=="production"?a(_==null||_[_.length-1].route.element!==void 0||_[_.length-1].route.Component!==void 0||_[_.length-1].route.lazy!==void 0,'Matched leaf route at location "'+y.pathname+y.search+y.hash+'" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'):void 0}let O=_renderMatches(_&&_.map((e=>Object.assign({},e,{params:Object.assign({},v,e.params),pathname:r([f,d.encodeLocation?d.encodeLocation(e.pathname).pathname:e.pathname]),pathnameBase:e.pathnameBase==="/"?f:r([f,d.encodeLocation?d.encodeLocation(e.pathnameBase).pathname:e.pathnameBase])}))),p,u,c);return n&&O?e.createElement(N.Provider,{value:{location:_extends({pathname:"/",search:"",hash:"",state:null,key:"default"},y),navigationType:i.Pop}},O):O}function DefaultErrorComponent(){let t=useRouteError();let r=c(t)?t.status+" "+t.statusText:t instanceof Error?t.message:JSON.stringify(t);let o=t instanceof Error?t.stack:null;let n="rgba(200,200,200, 0.5)";let a={padding:"0.5rem",backgroundColor:n};let u={padding:"2px 4px",backgroundColor:n};let s=null;if(process.env.NODE_ENV!=="production"){console.error("Error handled by React Router default ErrorBoundary:",t);s=e.createElement(e.Fragment,null,e.createElement("p",null,"ðŸ’¿ Hey developer ðŸ‘‹"),e.createElement("p",null,"You can provide a way better UX than this when your app throws errors by providing your own ",e.createElement("code",{style:u},"ErrorBoundary")," or"," ",e.createElement("code",{style:u},"errorElement")," prop on your route."))}return e.createElement(e.Fragment,null,e.createElement("h2",null,"Unexpected Application Error!"),e.createElement("h3",{style:{fontStyle:"italic"}},r),o?e.createElement("pre",{style:a},o):null,s)}const _=e.createElement(DefaultErrorComponent,null);class RenderErrorBoundary extends e.Component{constructor(e){super(e);this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,t){return t.location!==e.location||t.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:t.error,location:t.location,revalidation:e.revalidation||t.revalidation}}componentDidCatch(e,t){console.error("React Router caught the following error during render",e,t)}render(){return this.state.error!==void 0?e.createElement(C.Provider,{value:this.props.routeContext},e.createElement(D.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function RenderedRoute(t){let{routeContext:r,match:o,children:n}=t;let a=e.useContext(E);a&&a.static&&a.staticContext&&(o.route.errorElement||o.route.ErrorBoundary)&&(a.staticContext._deepestRenderedBoundaryId=o.route.id);return e.createElement(C.Provider,{value:r},n)}function _renderMatches(r,o,n,a){var u;o===void 0&&(o=[]);n===void 0&&(n=null);a===void 0&&(a=null);if(r==null){var s;if((s=n)==null||!s.errors)return null;r=n.matches}let l=r;let i=(u=n)==null?void 0:u.errors;if(i!=null){let e=l.findIndex((e=>e.route.id&&(i==null?void 0:i[e.route.id])));e>=0?void 0:process.env.NODE_ENV!=="production"?t(false,"Could not find a matching route for errors on route IDs: "+Object.keys(i).join(",")):t(false);l=l.slice(0,Math.min(l.length,e+1))}let c=false;let d=-1;if(n&&a&&a.v7_partialHydration)for(let e=0;e<l.length;e++){let t=l[e];(t.route.HydrateFallback||t.route.hydrateFallbackElement)&&(d=e);if(t.route.id){let{loaderData:e,errors:r}=n;let o=t.route.loader&&e[t.route.id]===void 0&&(!r||r[t.route.id]===void 0);if(t.route.lazy||o){c=true;l=d>=0?l.slice(0,d+1):[l[0]];break}}}return l.reduceRight(((t,r,a)=>{let u;let s=false;let p=null;let h=null;if(n){u=i&&r.route.id?i[r.route.id]:void 0;p=r.route.errorElement||_;if(c)if(d<0&&a===0){warningOnce("route-fallback",false,"No `HydrateFallback` element provided to render during initial hydration");s=true;h=null}else if(d===a){s=true;h=r.route.hydrateFallbackElement||null}}let v=o.concat(l.slice(0,a+1));let getChildren=()=>{let o;o=u?p:s?h:r.route.Component?e.createElement(r.route.Component,null):r.route.element?r.route.element:t;return e.createElement(RenderedRoute,{match:r,routeContext:{outlet:t,matches:v,isDataRoute:n!=null},children:o})};return n&&(r.route.ErrorBoundary||r.route.errorElement||a===0)?e.createElement(RenderErrorBoundary,{location:n.location,revalidation:n.revalidation,component:p,error:u,children:getChildren(),routeContext:{outlet:null,matches:v,isDataRoute:true}}):getChildren()}),null)}var O=function(e){e.UseBlocker="useBlocker";e.UseRevalidator="useRevalidator";e.UseNavigateStable="useNavigate";return e}(O||{});var S=function(e){e.UseBlocker="useBlocker";e.UseLoaderData="useLoaderData";e.UseActionData="useActionData";e.UseRouteError="useRouteError";e.UseNavigation="useNavigation";e.UseRouteLoaderData="useRouteLoaderData";e.UseMatches="useMatches";e.UseRevalidator="useRevalidator";e.UseNavigateStable="useNavigate";e.UseRouteId="useRouteId";return e}(S||{});function getDataRouterConsoleError(e){return e+" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router."}function useDataRouterContext(r){let o=e.useContext(E);o?void 0:process.env.NODE_ENV!=="production"?t(false,getDataRouterConsoleError(r)):t(false);return o}function useDataRouterState(r){let o=e.useContext(R);o?void 0:process.env.NODE_ENV!=="production"?t(false,getDataRouterConsoleError(r)):t(false);return o}function useRouteContext(r){let o=e.useContext(C);o?void 0:process.env.NODE_ENV!=="production"?t(false,getDataRouterConsoleError(r)):t(false);return o}function useCurrentRouteId(e){let r=useRouteContext(e);let o=r.matches[r.matches.length-1];o.route.id?void 0:process.env.NODE_ENV!=="production"?t(false,e+' can only be used on routes that contain a unique "id"'):t(false);return o.route.id}function useRouteId(){return useCurrentRouteId(S.UseRouteId)}function useNavigation(){let e=useDataRouterState(S.UseNavigation);return e.navigation}function useRevalidator(){let t=useDataRouterContext(O.UseRevalidator);let r=useDataRouterState(S.UseRevalidator);return e.useMemo((()=>({revalidate:t.router.revalidate,state:r.revalidation})),[t.router.revalidate,r.revalidation])}function useMatches(){let{matches:t,loaderData:r}=useDataRouterState(S.UseMatches);return e.useMemo((()=>t.map((e=>d(e,r)))),[t,r])}function useLoaderData(){let e=useDataRouterState(S.UseLoaderData);let t=useCurrentRouteId(S.UseLoaderData);if(!e.errors||e.errors[t]==null)return e.loaderData[t];console.error("You cannot `useLoaderData` in an errorElement (routeId: "+t+")")}function useRouteLoaderData(e){let t=useDataRouterState(S.UseRouteLoaderData);return t.loaderData[e]}function useActionData(){let e=useDataRouterState(S.UseActionData);let t=useCurrentRouteId(S.UseLoaderData);return e.actionData?e.actionData[t]:void 0}function useRouteError(){var t;let r=e.useContext(D);let o=useDataRouterState(S.UseRouteError);let n=useCurrentRouteId(S.UseRouteError);return r!==void 0?r:(t=o.errors)==null?void 0:t[n]}function useAsyncValue(){let t=e.useContext(y);return t==null?void 0:t._data}function useAsyncError(){let t=e.useContext(y);return t==null?void 0:t._error}let P=0;function useBlocker(t){let{router:r,basename:o}=useDataRouterContext(O.UseBlocker);let n=useDataRouterState(S.UseBlocker);let[a,u]=e.useState("");let s=e.useCallback((e=>{if(typeof t!=="function")return!!t;if(o==="/")return t(e);let{currentLocation:r,nextLocation:n,historyAction:a}=e;return t({currentLocation:_extends({},r,{pathname:p(r.pathname,o)||r.pathname}),nextLocation:_extends({},n,{pathname:p(n.pathname,o)||n.pathname}),historyAction:a})}),[o,t]);e.useEffect((()=>{let e=String(++P);u(e);return()=>r.deleteBlocker(e)}),[r]);e.useEffect((()=>{a!==""&&r.getBlocker(a,s)}),[r,a,s]);return a&&n.blockers.has(a)?n.blockers.get(a):h}function useNavigateStable(){let{router:t}=useDataRouterContext(O.UseNavigateStable);let r=useCurrentRouteId(S.UseNavigateStable);let o=e.useRef(false);useIsomorphicLayoutEffect((()=>{o.current=true}));let n=e.useCallback((function(e,n){n===void 0&&(n={});process.env.NODE_ENV!=="production"?a(o.current,b):void 0;o.current&&(typeof e==="number"?t.navigate(e):t.navigate(e,_extends({fromRouteId:r},n)))}),[t,r]);return n}const k={};function warningOnce(e,t,r){if(!t&&!k[e]){k[e]=true;process.env.NODE_ENV!=="production"?a(false,r):void 0}}const V="startTransition";const U=e[V];function RouterProvider(t){let{fallbackElement:r,router:o,future:n}=t;let[u,s]=e.useState(o.state);let{v7_startTransition:l}=n||{};let i=e.useCallback((e=>{l&&U?U((()=>s(e))):s(e)}),[s,l]);e.useLayoutEffect((()=>o.subscribe(i)),[o,i]);e.useEffect((()=>{process.env.NODE_ENV!=="production"?a(r==null||!o.future.v7_partialHydration,"`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead"):void 0}),[]);let c=e.useMemo((()=>({createHref:o.createHref,encodeLocation:o.encodeLocation,go:e=>o.navigate(e),push:(e,t,r)=>o.navigate(e,{state:t,preventScrollReset:r==null?void 0:r.preventScrollReset}),replace:(e,t,r)=>o.navigate(e,{replace:true,state:t,preventScrollReset:r==null?void 0:r.preventScrollReset})})),[o]);let d=o.basename||"/";let p=e.useMemo((()=>({router:o,navigator:c,static:false,basename:d})),[o,c,d]);return e.createElement(e.Fragment,null,e.createElement(E.Provider,{value:p},e.createElement(R.Provider,{value:u},e.createElement(Router,{basename:d,location:u.location,navigationType:u.historyAction,navigator:c,future:{v7_relativeSplatPath:o.future.v7_relativeSplatPath}},u.initialized||o.future.v7_partialHydration?e.createElement(DataRoutes,{routes:o.routes,future:o.future,state:u}):r))),null)}function DataRoutes(e){let{routes:t,future:r,state:o}=e;return useRoutesImpl(t,void 0,o,r)}function MemoryRouter(t){let{basename:r,children:o,initialEntries:n,initialIndex:a,future:u}=t;let s=e.useRef();s.current==null&&(s.current=v({initialEntries:n,initialIndex:a,v5Compat:true}));let l=s.current;let[i,c]=e.useState({action:l.action,location:l.location});let{v7_startTransition:d}=u||{};let p=e.useCallback((e=>{d&&U?U((()=>c(e))):c(e)}),[c,d]);e.useLayoutEffect((()=>l.listen(p)),[l,p]);return e.createElement(Router,{basename:r,children:o,location:i.location,navigationType:i.action,navigator:l,future:u})}function Navigate(r){let{to:o,replace:s,state:l,relative:i}=r;useInRouterContext()?void 0:process.env.NODE_ENV!=="production"?t(false,"<Navigate> may be used only in the context of a <Router> component."):t(false);let{future:c,static:d}=e.useContext(g);process.env.NODE_ENV!=="production"?a(!d,"<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."):void 0;let{matches:p}=e.useContext(C);let{pathname:h}=useLocation();let v=useNavigate();let m=u(o,n(p,c.v7_relativeSplatPath),h,i==="path");let f=JSON.stringify(m);e.useEffect((()=>v(JSON.parse(f),{replace:s,state:l,relative:i})),[v,f,i,s,l]);return null}function Outlet(e){return useOutlet(e.context)}function Route(e){process.env.NODE_ENV!=="production"?t(false,"A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>."):t(false)}function Router(r){let{basename:o="/",children:n=null,location:u,navigationType:l=i.Pop,navigator:c,static:d=false,future:h}=r;!useInRouterContext()?void 0:process.env.NODE_ENV!=="production"?t(false,"You cannot render a <Router> inside another <Router>. You should never have more than one in your app."):t(false);let v=o.replace(/^\/*/,"/");let m=e.useMemo((()=>({basename:v,navigator:c,static:d,future:_extends({v7_relativeSplatPath:false},h)})),[v,h,c,d]);typeof u==="string"&&(u=s(u));let{pathname:f="/",search:E="",hash:R="",state:y=null,key:C="default"}=u;let D=e.useMemo((()=>{let e=p(f,v);return e==null?null:{location:{pathname:e,search:E,hash:R,state:y,key:C},navigationType:l}}),[v,f,E,R,y,C,l]);process.env.NODE_ENV!=="production"?a(D!=null,'<Router basename="'+v+'"> is not able to match the URL "'+f+E+R+"\" because it does not start with the basename, so the <Router> won't render anything."):void 0;return D==null?null:e.createElement(g.Provider,{value:m},e.createElement(N.Provider,{children:n,value:D}))}function Routes(e){let{children:t,location:r}=e;return useRoutes(createRoutesFromChildren(t),r)}function Await(t){let{children:r,errorElement:o,resolve:n}=t;return e.createElement(AwaitErrorBoundary,{resolve:n,errorElement:o},e.createElement(ResolveAwait,null,r))}var L=function(e){e[e.pending=0]="pending";e[e.success=1]="success";e[e.error=2]="error";return e}(L||{});const w=new Promise((()=>{}));class AwaitErrorBoundary extends e.Component{constructor(e){super(e);this.state={error:null}}static getDerivedStateFromError(e){return{error:e}}componentDidCatch(e,t){console.error("<Await> caught the following error during render",e,t)}render(){let{children:t,errorElement:r,resolve:o}=this.props;let n=null;let a=L.pending;if(o instanceof Promise)if(this.state.error){a=L.error;let e=this.state.error;n=Promise.reject().catch((()=>{}));Object.defineProperty(n,"_tracked",{get:()=>true});Object.defineProperty(n,"_error",{get:()=>e})}else if(o._tracked){n=o;a=n._error!==void 0?L.error:n._data!==void 0?L.success:L.pending}else{a=L.pending;Object.defineProperty(o,"_tracked",{get:()=>true});n=o.then((e=>Object.defineProperty(o,"_data",{get:()=>e})),(e=>Object.defineProperty(o,"_error",{get:()=>e})))}else{a=L.success;n=Promise.resolve();Object.defineProperty(n,"_tracked",{get:()=>true});Object.defineProperty(n,"_data",{get:()=>o})}if(a===L.error&&n._error instanceof m)throw w;if(a===L.error&&!r)throw n._error;if(a===L.error)return e.createElement(y.Provider,{value:n,children:r});if(a===L.success)return e.createElement(y.Provider,{value:n,children:t});throw n}}function ResolveAwait(t){let{children:r}=t;let o=useAsyncValue();let n=typeof r==="function"?r(o):r;return e.createElement(e.Fragment,null,n)}function createRoutesFromChildren(r,o){o===void 0&&(o=[]);let n=[];e.Children.forEach(r,((r,a)=>{if(!e.isValidElement(r))return;let u=[...o,a];if(r.type===e.Fragment){n.push.apply(n,createRoutesFromChildren(r.props.children,u));return}r.type===Route?void 0:process.env.NODE_ENV!=="production"?t(false,"["+(typeof r.type==="string"?r.type:r.type.name)+"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>"):t(false);!r.props.index||!r.props.children?void 0:process.env.NODE_ENV!=="production"?t(false,"An index route cannot have child routes."):t(false);let s={id:r.props.id||u.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(s.children=createRoutesFromChildren(r.props.children,u));n.push(s)}));return n}function renderMatches(e){return _renderMatches(e)}function mapRouteProperties(t){let r={hasErrorBoundary:t.ErrorBoundary!=null||t.errorElement!=null};if(t.Component){process.env.NODE_ENV!=="production"&&t.element&&(process.env.NODE_ENV!=="production"?a(false,"You should not include both `Component` and `element` on your route - `Component` will be used."):void 0);Object.assign(r,{element:e.createElement(t.Component),Component:void 0})}if(t.HydrateFallback){process.env.NODE_ENV!=="production"&&t.hydrateFallbackElement&&(process.env.NODE_ENV!=="production"?a(false,"You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."):void 0);Object.assign(r,{hydrateFallbackElement:e.createElement(t.HydrateFallback),HydrateFallback:void 0})}if(t.ErrorBoundary){process.env.NODE_ENV!=="production"&&t.errorElement&&(process.env.NODE_ENV!=="production"?a(false,"You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."):void 0);Object.assign(r,{errorElement:e.createElement(t.ErrorBoundary),ErrorBoundary:void 0})}return r}function createMemoryRouter(e,t){return f({basename:t==null?void 0:t.basename,future:_extends({},t==null?void 0:t.future,{v7_prependBasename:true}),history:v({initialEntries:t==null?void 0:t.initialEntries,initialIndex:t==null?void 0:t.initialIndex}),hydrationData:t==null?void 0:t.hydrationData,routes:e,mapRouteProperties:mapRouteProperties}).initialize()}export{Await,MemoryRouter,Navigate,Outlet,Route,Router,RouterProvider,Routes,E as UNSAFE_DataRouterContext,R as UNSAFE_DataRouterStateContext,N as UNSAFE_LocationContext,g as UNSAFE_NavigationContext,C as UNSAFE_RouteContext,mapRouteProperties as UNSAFE_mapRouteProperties,useRouteId as UNSAFE_useRouteId,useRoutesImpl as UNSAFE_useRoutesImpl,createMemoryRouter,createRoutesFromChildren,createRoutesFromChildren as createRoutesFromElements,renderMatches,useActionData,useAsyncError,useAsyncValue,useBlocker,useHref,useInRouterContext,useLoaderData,useLocation,useMatch,useMatches,useNavigate,useNavigation,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRevalidator,useRouteError,useRouteLoaderData,useRoutes};

